import 'package:flutter/foundation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import '../../entities/alerta_stock_entity.dart';
import '../../entities/categoria_equipamiento_entity.dart';
import '../../entities/item_revision_entity.dart';
import '../../entities/movimiento_stock_entity.dart';
import '../../entities/producto_entity.dart';
import '../../entities/revision_mensual_entity.dart';
import '../../entities/stock_minimo_entity.dart';
import '../../entities/stock_vehiculo_entity.dart';
import '../../models/alerta_stock_supabase_model.dart';
import '../../models/categoria_equipamiento_supabase_model.dart';
import '../../models/item_revision_supabase_model.dart';
import '../../models/movimiento_stock_supabase_model.dart';
import '../../models/producto_supabase_model.dart';
import '../../models/revision_mensual_supabase_model.dart';
import '../../models/stock_minimo_supabase_model.dart';
import '../../models/stock_vehiculo_supabase_model.dart';
import '../../stock_contract.dart';

/// Implementaci√≥n Supabase del datasource de Stock
class SupabaseStockDataSource implements StockDataSource {
  /// Cliente de Supabase
  final SupabaseClient _supabase;

  /// Constructor
  SupabaseStockDataSource({SupabaseClient? supabase})
      : _supabase = supabase ?? Supabase.instance.client;

  // ========================================================================
  // CATEGOR√çAS DE EQUIPAMIENTO
  // ========================================================================

  @override
  Future<List<CategoriaEquipamientoEntity>> getCategorias() async {
    try {
      debugPrint('üì¶ StockDataSource: Obteniendo categor√≠as...');

      final response = await _supabase
          .from('categorias_equipamiento')
          .select()
          .order('orden');

      final List<CategoriaEquipamientoEntity> categorias = (response as List)
          .map(
            (json) => CategoriaEquipamientoSupabaseModel.fromJson(
              json as Map<String, dynamic>,
            ).toEntity(),
          )
          .toList();

      debugPrint('üì¶ StockDataSource: ‚úÖ ${categorias.length} categor√≠as obtenidas');
      return categorias;
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error al obtener categor√≠as: $e');
      rethrow;
    }
  }

  @override
  Future<CategoriaEquipamientoEntity?> getCategoriaById(String id) async {
    try {
      final response = await _supabase
          .from('categorias_equipamiento')
          .select()
          .eq('id', id)
          .maybeSingle();

      if (response == null) return null;

      return CategoriaEquipamientoSupabaseModel.fromJson(
        response as Map<String, dynamic>,
      ).toEntity();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error al obtener categor√≠a: $e');
      rethrow;
    }
  }

  // ========================================================================
  // PRODUCTOS
  // ========================================================================

  @override
  Future<List<ProductoEntity>> getProductos() async {
    try {
      debugPrint('üì¶ StockDataSource: Obteniendo productos...');

      final response = await _supabase
          .from('productos')
          .select()
          .eq('activo', true)
          .order('nombre');

      final List<ProductoEntity> productos = (response as List)
          .map(
            (json) => ProductoSupabaseModel.fromJson(
              json as Map<String, dynamic>,
            ).toEntity(),
          )
          .toList();

      debugPrint('üì¶ StockDataSource: ‚úÖ ${productos.length} productos obtenidos');
      return productos;
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error al obtener productos: $e');
      rethrow;
    }
  }

  @override
  Future<List<ProductoEntity>> getProductosByCategoria(
    String categoriaId,
  ) async {
    try {
      final response = await _supabase
          .from('productos')
          .select()
          .eq('categoria_id', categoriaId)
          .eq('activo', true)
          .order('nombre');

      return (response as List)
          .map(
            (json) => ProductoSupabaseModel.fromJson(
              json as Map<String, dynamic>,
            ).toEntity(),
          )
          .toList();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error: $e');
      rethrow;
    }
  }

  @override
  Future<ProductoEntity?> getProductoById(String id) async {
    try {
      final response = await _supabase
          .from('productos')
          .select()
          .eq('id', id)
          .maybeSingle();

      if (response == null) return null;

      return ProductoSupabaseModel.fromJson(
        response as Map<String, dynamic>,
      ).toEntity();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error: $e');
      rethrow;
    }
  }

  @override
  Future<ProductoEntity> createProducto(ProductoEntity producto) async {
    try {
      final model = ProductoSupabaseModel.fromEntity(producto);
      final response = await _supabase
          .from('productos')
          .insert(model.toJson())
          .select()
          .single();

      return ProductoSupabaseModel.fromJson(
        response as Map<String, dynamic>,
      ).toEntity();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error al crear producto: $e');
      rethrow;
    }
  }

  @override
  Future<ProductoEntity> updateProducto(ProductoEntity producto) async {
    try {
      final model = ProductoSupabaseModel.fromEntity(producto);
      final response = await _supabase
          .from('productos')
          .update(model.toJson())
          .eq('id', producto.id)
          .select()
          .single();

      return ProductoSupabaseModel.fromJson(
        response as Map<String, dynamic>,
      ).toEntity();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error al actualizar producto: $e');
      rethrow;
    }
  }

  @override
  Future<void> deleteProducto(String id) async {
    try {
      await _supabase.from('productos').delete().eq('id', id);
      debugPrint('üì¶ StockDataSource: ‚úÖ Producto eliminado');
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error al eliminar producto: $e');
      rethrow;
    }
  }

  // ========================================================================
  // STOCK M√çNIMO POR TIPO
  // ========================================================================

  @override
  Future<StockMinimoEntity?> getStockMinimo(
    String productoId,
    String tipoVehiculo,
  ) async {
    try {
      final response = await _supabase
          .from('stock_minimo_por_tipo')
          .select()
          .eq('producto_id', productoId)
          .eq('tipo_vehiculo', tipoVehiculo)
          .maybeSingle();

      if (response == null) return null;

      return StockMinimoSupabaseModel.fromJson(
        response as Map<String, dynamic>,
      ).toEntity();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error: $e');
      rethrow;
    }
  }

  @override
  Future<List<StockMinimoEntity>> getStockMinimoByTipo(
    String tipoVehiculo,
  ) async {
    try {
      final response = await _supabase
          .from('stock_minimo_por_tipo')
          .select()
          .eq('tipo_vehiculo', tipoVehiculo);

      return (response as List)
          .map(
            (json) => StockMinimoSupabaseModel.fromJson(
              json as Map<String, dynamic>,
            ).toEntity(),
          )
          .toList();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error: $e');
      rethrow;
    }
  }

  @override
  Future<StockMinimoEntity> upsertStockMinimo(
    StockMinimoEntity stockMinimo,
  ) async {
    try {
      final model = StockMinimoSupabaseModel.fromEntity(stockMinimo);
      final response = await _supabase
          .from('stock_minimo_por_tipo')
          .upsert(model.toJson())
          .select()
          .single();

      return StockMinimoSupabaseModel.fromJson(
        response as Map<String, dynamic>,
      ).toEntity();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error: $e');
      rethrow;
    }
  }

  // ========================================================================
  // STOCK DE VEH√çCULO
  // ========================================================================

  @override
  Future<List<StockVehiculoEntity>> getStockVehiculo(String vehiculoId) async {
    try {
      debugPrint('üì¶ StockDataSource: Obteniendo stock del veh√≠culo $vehiculoId...');

      final response = await _supabase
          .from('v_stock_vehiculo_estado')
          .select()
          .eq('vehiculo_id', vehiculoId)
          .order('categoria_codigo')
          .order('producto_nombre');

      final List<StockVehiculoEntity> items = (response as List)
          .map(
            (json) => StockVehiculoSupabaseModel.fromJson(
              json as Map<String, dynamic>,
            ).toEntity(),
          )
          .toList();

      debugPrint('üì¶ StockDataSource: ‚úÖ ${items.length} items de stock obtenidos');
      return items;
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error al obtener stock: $e');
      rethrow;
    }
  }

  @override
  Future<StockVehiculoEntity?> getStockById(String id) async {
    try {
      final response = await _supabase
          .from('v_stock_vehiculo_estado')
          .select()
          .eq('id', id)
          .maybeSingle();

      if (response == null) return null;

      return StockVehiculoSupabaseModel.fromJson(
        response as Map<String, dynamic>,
      ).toEntity();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error: $e');
      rethrow;
    }
  }

  @override
  Future<StockVehiculoEntity> updateStock(StockVehiculoEntity stock) async {
    try {
      final model = StockVehiculoSupabaseModel.fromEntity(stock);
      final response = await _supabase
          .from('stock_vehiculo')
          .update(model.toJson())
          .eq('id', stock.id)
          .select()
          .single();

      return StockVehiculoSupabaseModel.fromJson(
        response as Map<String, dynamic>,
      ).toEntity();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error al actualizar stock: $e');
      rethrow;
    }
  }

  // ========================================================================
  // MOVIMIENTOS DE STOCK
  // ========================================================================

  @override
  Future<Map<String, dynamic>> registrarMovimiento({
    required String vehiculoId,
    required String productoId,
    required String tipo,
    required int cantidad,
    String? lote,
    DateTime? fechaCaducidad,
    String? motivo,
    String? usuarioId,
  }) async {
    try {
      debugPrint('üì¶ StockDataSource: Registrando movimiento de stock...');

      final response = await _supabase.rpc(
        'registrar_movimiento_stock',
        params: <String, dynamic>{
          'p_vehiculo_id': vehiculoId,
          'p_producto_id': productoId,
          'p_tipo': tipo,
          'p_cantidad': cantidad,
          'p_lote': lote,
          'p_fecha_caducidad': fechaCaducidad?.toIso8601String(),
          'p_motivo': motivo,
          'p_usuario_id': usuarioId ?? _supabase.auth.currentUser?.id,
        },
      );

      debugPrint('üì¶ StockDataSource: ‚úÖ Movimiento registrado');
      return response as Map<String, dynamic>;
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error al registrar movimiento: $e');
      rethrow;
    }
  }

  @override
  Future<List<MovimientoStockEntity>> getHistorialMovimientos({
    String? vehiculoId,
    String? productoId,
    DateTime? desde,
    DateTime? hasta,
    int limit = 50,
  }) async {
    try {
      var query = _supabase
          .from('movimientos_stock')
          .select('*, productos(nombre), vehiculos(matricula)');

      if (vehiculoId != null) {
        query = query.eq('vehiculo_id', vehiculoId);
      }
      if (productoId != null) {
        query = query.eq('producto_id', productoId);
      }
      if (desde != null) {
        query = query.gte('created_at', desde.toIso8601String());
      }
      if (hasta != null) {
        query = query.lte('created_at', hasta.toIso8601String());
      }

      final response =
          await query.order('created_at', ascending: false).limit(limit);

      return (response as List)
          .map(
            (json) => MovimientoStockSupabaseModel.fromJson(
              json as Map<String, dynamic>,
            ).toEntity(),
          )
          .toList();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error: $e');
      rethrow;
    }
  }

  // ========================================================================
  // ALERTAS
  // ========================================================================

  @override
  Future<List<AlertaStockEntity>> getAlertasVehiculo(String vehiculoId) async {
    try {
      final response = await _supabase
          .from('alertas_stock')
          .select('*, productos(nombre), vehiculos(matricula)')
          .eq('vehiculo_id', vehiculoId)
          .eq('resuelta', false)
          .order('nivel', ascending: false)
          .order('created_at', ascending: false);

      return (response as List)
          .map(
            (json) => AlertaStockSupabaseModel.fromJson(
              json as Map<String, dynamic>,
            ).toEntity(),
          )
          .toList();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error: $e');
      rethrow;
    }
  }

  @override
  Future<List<AlertaStockEntity>> getAlertasActivas() async {
    try {
      final response = await _supabase
          .from('alertas_stock')
          .select('*, productos(nombre), vehiculos(matricula)')
          .eq('resuelta', false)
          .order('nivel', ascending: false)
          .order('created_at', ascending: false);

      return (response as List)
          .map(
            (json) => AlertaStockSupabaseModel.fromJson(
              json as Map<String, dynamic>,
            ).toEntity(),
          )
          .toList();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error: $e');
      rethrow;
    }
  }

  @override
  Future<void> resolverAlerta(String alertaId, String usuarioId) async {
    try {
      await _supabase.from('alertas_stock').update(<String, dynamic>{
        'resuelta': true,
        'resuelta_por': usuarioId,
        'resuelta_at': DateTime.now().toIso8601String(),
      }).eq('id', alertaId);

      debugPrint('üì¶ StockDataSource: ‚úÖ Alerta resuelta');
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error al resolver alerta: $e');
      rethrow;
    }
  }

  @override
  Future<void> generarAlertas() async {
    try {
      debugPrint('üì¶ StockDataSource: Generando alertas autom√°ticas...');
      await _supabase.rpc('generar_alertas_stock');
      debugPrint('üì¶ StockDataSource: ‚úÖ Alertas generadas');
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error al generar alertas: $e');
      rethrow;
    }
  }

  // ========================================================================
  // REVISIONES MENSUALES
  // ========================================================================

  @override
  Future<List<RevisionMensualEntity>> getRevisionesVehiculo(
    String vehiculoId,
  ) async {
    try {
      final response = await _supabase
          .from('revisiones_mensuales')
          .select()
          .eq('vehiculo_id', vehiculoId)
          .order('fecha', ascending: false);

      return (response as List)
          .map(
            (json) => RevisionMensualSupabaseModel.fromJson(
              json as Map<String, dynamic>,
            ).toEntity(),
          )
          .toList();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error: $e');
      rethrow;
    }
  }

  @override
  Future<RevisionMensualEntity?> getRevisionById(String id) async {
    try {
      final response = await _supabase
          .from('revisiones_mensuales')
          .select()
          .eq('id', id)
          .maybeSingle();

      if (response == null) return null;

      return RevisionMensualSupabaseModel.fromJson(
        response as Map<String, dynamic>,
      ).toEntity();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error: $e');
      rethrow;
    }
  }

  @override
  Future<RevisionMensualEntity> createRevision(
    RevisionMensualEntity revision,
  ) async {
    try {
      final model = RevisionMensualSupabaseModel.fromEntity(revision);
      final response = await _supabase
          .from('revisiones_mensuales')
          .insert(model.toJson())
          .select()
          .single();

      return RevisionMensualSupabaseModel.fromJson(
        response as Map<String, dynamic>,
      ).toEntity();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error al crear revisi√≥n: $e');
      rethrow;
    }
  }

  @override
  Future<RevisionMensualEntity> updateRevision(
    RevisionMensualEntity revision,
  ) async {
    try {
      final model = RevisionMensualSupabaseModel.fromEntity(revision);
      final response = await _supabase
          .from('revisiones_mensuales')
          .update(model.toJson())
          .eq('id', revision.id)
          .select()
          .single();

      return RevisionMensualSupabaseModel.fromJson(
        response as Map<String, dynamic>,
      ).toEntity();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error al actualizar revisi√≥n: $e');
      rethrow;
    }
  }

  @override
  Future<RevisionMensualEntity> completarRevision(
    String revisionId,
    String? firmaBase64,
    String? observaciones,
  ) async {
    try {
      final response = await _supabase
          .from('revisiones_mensuales')
          .update(<String, dynamic>{
        'completada': true,
        'firma_base64': firmaBase64,
        'observaciones_generales': observaciones,
        'completed_at': DateTime.now().toIso8601String(),
      }).eq('id', revisionId).select().single();

      return RevisionMensualSupabaseModel.fromJson(
        response as Map<String, dynamic>,
      ).toEntity();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error al completar revisi√≥n: $e');
      rethrow;
    }
  }

  // ========================================================================
  // ITEMS DE REVISI√ìN
  // ========================================================================

  @override
  Future<List<ItemRevisionEntity>> getItemsRevision(String revisionId) async {
    try {
      final response = await _supabase
          .from('items_revision')
          .select()
          .eq('revision_id', revisionId)
          .order('created_at');

      return (response as List)
          .map(
            (json) => ItemRevisionSupabaseModel.fromJson(
              json as Map<String, dynamic>,
            ).toEntity(),
          )
          .toList();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error: $e');
      rethrow;
    }
  }

  @override
  Future<ItemRevisionEntity> updateItemRevision(ItemRevisionEntity item) async {
    try {
      final model = ItemRevisionSupabaseModel.fromEntity(item);
      final response = await _supabase
          .from('items_revision')
          .update(model.toJson())
          .eq('id', item.id)
          .select()
          .single();

      return ItemRevisionSupabaseModel.fromJson(
        response as Map<String, dynamic>,
      ).toEntity();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error: $e');
      rethrow;
    }
  }

  @override
  Future<ItemRevisionEntity> verificarItem(
    String itemId,
    int cantidadEncontrada,
    bool caducidadOk,
    String estado,
    String? observacion,
  ) async {
    try {
      final response = await _supabase.from('items_revision').update(<String, dynamic>{
        'verificado': true,
        'cantidad_encontrada': cantidadEncontrada,
        'caducidad_ok': caducidadOk,
        'estado': estado,
        'observacion': observacion,
      }).eq('id', itemId).select().single();

      return ItemRevisionSupabaseModel.fromJson(
        response as Map<String, dynamic>,
      ).toEntity();
    } catch (e) {
      debugPrint('üì¶ StockDataSource: ‚ùå Error: $e');
      rethrow;
    }
  }
}
